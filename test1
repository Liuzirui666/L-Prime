进程调度算法：操作系统上的进程很多，操作系统需要平衡各个进程的运行时间。比如说有的进程运行时间已经很长了，已经占用了cpu很长时间了，这个时候操作系统要公平就会换下一个需要运行的进程。这里，我们将实现一个简单的抢占式进程调度算法。

读入一组进程信息，使用方法调度进程，进程信息包括：优先级、开始时间、若干时间片。其中时间类型为（长）整型。我们这里假设需要调度的进程数最多不超过100个。

进程间的调度规则如下：

优先级数字越大优先级越高（优先级在1-10之间），当Pi运行时，如果存在比Pi优先级高 2 的进程，可以抢占执行。
当前进程Pi执行完当前时间片（进程在时间片中不能被打断），我们或者继续执行本进程，或者执行一个抢占的进程；从所有已开始的进程中挑选出一个具有最高优先级的进程进行执行；如果具有多个进程具有最高优先级，则挑选启动时间最早的进程。
Pi每执行完当前时间片，其优先级下降1，其它等待中的进程优先级上升1。
输入中不存在两个同时开始的进程。
输入输出
输入：
输入为i行，i为调度进程数，每行的输入包括进程编号，进程优先级，进程开始时间，一个或多个该进程需要执行任务的时间片长度，具体格式如下：
[PID 优先级 开始时间 时间片1 时间片2 …]，
示例：
[P1 1 1000 100 20 30]
表示该进程为P1，优先级为1，开始时间为1000，该示例进程包含三个任务，第一个任务完成时间片长度为100，第二个任务完成时间片长度为20，第三个任务完成时间片长度为30，各时间片的执行顺序不得改变，且不能被中断。

输出：
输出进程完成的结束时间序列，格式如下：P1 P2 P3 …

开始你的任务吧，祝你成功！
